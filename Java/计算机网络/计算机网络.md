## 七层架构

物理层：主要**定义物理设备标准**，数据称为比特。

数据链路层：主要从物理层接受的数据**进行MAC地址的封装与解封装**。工作设备为交换机，数据称为帧。

网络层：主要将从下层接受到的数据**进行IP地址的封装与解封装**。工作设备为路由器，数据称为数据包。

传输层：**定义了一些传输数据的协议和端口号**，如TCP、UDP。数据称为段。

会话层：通过传输层**建立数据传输通路**。

表示层：对接收的数据**进行解释、加密与解密、压缩与解压缩**。

应用层：终端应用。











## 三次握手



![image-20210904193904819](.\img\image-20210904193904819.png)

1. 主机A发送同步序号位码SYN,产生一个序列号，发送给主机B
2. 主机B收到后，要确认联机信息，向A发送 同步序号位码SYN、确认位码ACK、序列号、确认号
3. 主机A收到B发送的数据包后，检查确认号是否正确，如果正确，则向B发送确认位码ACK、序列号、确认号

> **为什么A最后还要发送一次确认？**
>
> 主要是为了防止已经失效的连接请求报文突然又传送到了B，产生错误。

## 四次挥手

![image-20210904150921079](.\img\image-20210904150921079.png)

1. 客户端A发送一个**终止标志位 FIN**，产生一个**序列号**，此时A进入**终止等待状态**(FIN-WAIT)
2. 服务器B收到FIN标志位，发回一个**确认位ACK**，产生一个**序列号**，确认号为A的**序列号**+1。B进入**关闭等待状态**(CLOSE-WAIT)，此时TCP服务进程通知应用进程，A到B的连接就释放了，此时是“**半关闭状态**”
3. 若B没有数据报要发送给A了，就给A发送一个**终止标志位FIN**，发送一个**确认位**，产生一个**序列号**，**确认号**是A的序列号+1，此时B进入**最后确认状态**(LAST-ACK)
4. A收到FIN后，发回一个**确认位ACK**,**确认号**是B的序列号+1，（序列号为A的序列号+1），A进入到**时间等待状态**(TIME-WAIT)，在等待2MSL后，A进入**关闭状态**。

> MSL：最大报文段寿命
>
> **为什么A在时间等待状态必须等待2MSL？**
>
> 为了保证A发送的最后一个ACK报文段能够到达B。
>
> 防止“已失效的连接请求报文段”出现在本连接中。

TCP还有一个保活计时器：

每收到一次客户的数据，就重置这个计数器。

当2小时没有收到数据，就会发送探测报文段，连续发送10次后，若还无响应，就认为客户端出问题了，就关闭这个连接。

## 运输层

网络层提供主机之间的逻辑通信、**运输层为应用程序之间提供端到端的逻辑通信**。

端口号：为了找到对方计算机中的应用进程。

服务器端使用的端口号：

- 熟知端口号(0-1024)
  - FTP:20 TELNET:23 SMTP:25 DNS:53 HTTP:80 SNMP:161 HTTPS:443
  - 登记端口号(1024-49151)

- 客户端使用的端口号(49152-65535)

### 1. UDP：用户数据报协议

无连接的、面向报文、尽最大努力交付、没有拥塞控制，

UDP首部：源端口、目的端口、长度、校验和（每个字段2个字节）

UDP的校验和**是把首部和数据部分一起都检验**。

### 2. TCP：传输控制协议

面向连接、可靠交付、全双工、面向字节流（TCP把应用程序交下来的数据看出一串**无结构的字节流**）

TCP把连接作为最基本的对象。TCP连接的端点 叫**套接字(socket)**，

> 套接字：IP地址:端口号

每一条TCP连接唯一地被通信两端的两个端点（套接字）所确定。



TCP头部信息：最小长度是20位

- 序列号：4个字节，范围[0,2^32-1]，指本报文段所发送的数据的第一个字节的序号

- 确认号：期望收到对方下一个报文段的第一个数据字节的序列号

> 确认号=N，表示到序号N-1为止的所有数据都已正确收到

- 紧急指针：指出紧急数据的末尾在报文段中的位置(URG=1时才有效)

- 4位首部长度(数据偏移)：指出TCP报文段中数据的位置，因为TCP首部只有20字节是确定的，还有一个**选项**无法确定大小。

- URG：紧急位，URG=1，表明紧急指针字段有效，报文段中有紧急数据，应尽快传送，会把紧急数据插入到本报文段数据的最前面

- ACK：确认位，连接建立后，所有传输报文段的ACK=1

- PSH：推送，PSH=1，本报文段会立即发送出去，接收方不会再等缓存填满再向上交付。

- RST：复位，RST=1，表明TCP连接出现严重的差错，必须释放连接，重新建立连接。

- SYN：同步，连接时用来同步序号，SYN=1，ACK=0，表明这是一个 连接请求 报文段，SYN=1,ACK=1，表明这是一个  连接接受报文段。

- FIN：终止，释放连接

- 窗口：发送本报文段的一方的接受窗口。

- 校验和：校验首部和数据这两部分。

- 选项
  - 最大报文长度：MSS，表明每一个TCP报文段中**数据字段的最大长度** ，MSS默认536，加上固定首部的长度就是 556字节（互联网上所有主机都能接受的报文长度）
  - 窗口扩大选项
  - 时间戳：计算RTT；防止序号绕回PAWS

![image-20210905105236627](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210905105236627.png)

![image-20210905202746429](.\img\image-20210905202746429.png)

#### 2.1 TCP可靠传输的实现

##### 2.1.1 滑动窗口

![image-20210905203023159](.\img\image-20210905203023159.png)

发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据都发送出去

接收窗口中的，只能对按序收到的数据中的最高序号给出确认，在交付给主机后，会删除这些数据，将接收窗口向前滑动。

发送窗口在接收道确认后，也会向前滑动。

P3 - P1 = A 的发送窗口

P2 - P1 = 已发送但未收到确认的字节数

P3 - P2 = 允许发送，但当前未收到确认的字节数 （又称为 可用窗口） 

- 滑动窗口，根据对方发送的**窗口大小和确认号**来确定自己的发送窗口。

- 发送窗口是发送缓存的一部分，接收窗口是接收缓存的一部分。
  - 发送缓存存储：发送应用程序   传送  给  发送方TCP准备发送的数据；TCP已发出但未收到确认的数据
  - 接收缓存存储：按序到达、但尚未被接收应用程序读取的数据；未按序到达的数据

- 利用滑动窗口实现流量控制，
  - 让发送方的发送速率不要太快，要让接收方来得及接受
  - 持续计时器，解决

  > B向A发送0窗口不久后，又发送了rwnd = 400 （表示自己的接受窗口有400 ），但这条丢失了
  >
  >  A一直等待收到 B 发送的非0窗口，B也一直等待A 发送的数据，陷入死锁的僵局

- 只要TCP连接的一方收到对方的0窗口通知，就启动 持续计时器，只要时间到达设定值，就会发送一个0窗口**探测报文段**。确认对方的窗口是否是0。如果不是0，死锁的僵局就被打破了。

##### 2.1.2 超时重传

TCP发送方在规定时间内，没有收到确认，就会重传已经发送的报文

> 超时重传时间  RTO =  RTTs + 4 * RTTd
>
> RTTd 是RTT 的偏差的加权平均值  新的 RTTd =  (1 - β) * (旧的RTTd) + β * | RTTs - 新的RTT样本 |
>
> RTTs 是RTT的一个加权平均往返时间 RTTs =  (1 - α) * (旧的RTTs) + α * (新的RTT样本)
>
> α一般取值 0.125 ，β一般取值 0.25 
>
> 第一次测量是 RTTd 的取值为样本 RTT 的一半，RTTs 取值为 RTT 样本值

​	报文每重传一次，就把超时重传时间RTO增大一些（一般为2倍），等到不再发生重传时，才根据公式

##### 2.1.3  选择确认SACK

解决的是，若收的报文无差错，只是未按序号，中间还缺少一些数据，就形成了一些不连续的字节快，能否**只传送缺少的数据**而**不重传已经正确收到的数据**。

在TCP连接的时候，首部增加了SACK选项，以便报告收到的不连续字节块的边界，

#### 2.2 TCP拥塞控制方法

拥塞控制是防止过多的数据注入到网络中，使网络中的路由器或链路不过载。

##### 2.2.1 慢开始、拥塞避免

- 发送方有一个拥塞窗口cwnd，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化。

- 发送方让自己的发送窗口等于拥塞窗口。

- 判断网络拥塞的一句就是出现了**超时**。

**慢开始**：主机开始发送数据时，由小到大逐渐增大发送窗口，也就是说，由**由小到大逐渐增大拥塞窗口数值**。每过一次传输轮次，拥塞窗口cwnd就会**加倍**（增加量 = min ( N , SMSS )），直到达到慢开始门限（ssthresh）

**拥塞控制**：达到ssthresh后，拥塞窗口cwnd开始**按线性规律缓慢增长**，每次只增加一个MSS的大小，单位是字节。

> SMSS：发送方最大报文段
>
> MSS：最大报文段

当出现超时后，发送方判定为网络拥塞，于是调整门限值ssthresh = cwnd  /  2，即将门限值设置为发生拥塞时拥塞窗口大小的一半，同时设置拥塞窗口cwnd为一个MSS的大小，进入慢开始阶段。

##### 2.2.2 快重传、快恢复

**快重传**：尽快知道发生了个别报文段的丢失。接收方收到了不连续的报文段，会向发送方发送已收到的报文段的**重复确认，发送3次**，**发送方只要一连收到3个重复确认**，就会对缺少的报文段**立即重传**

**快恢复**：在快重传后，发送方调整门限值ssthresh = cwnd  / 2，即将门限值调整为当前拥塞窗口的一半，同时设置拥塞窗口为该门限值，然后开始执行拥塞避免算法。

![image-20210905202502231](.\img\image-20210905202502231.png)

发送窗口的上限值： MIN【rwnd，cwnd】，取接收方窗口rwnd 和 拥塞窗口 cwnd 中较小的。

#### 主动队列管理 AQM

避免发生网络中的全局同步（使全网的通信量突然下降很多，网络恢复正常后，通信量又突然增大很多）

等到路由器中的队列长度达到某一值得警惕的数值时，就主动丢弃达到的分组，就提醒发送方放慢发送速率。

