# 垃圾回收

## 1. 垃圾回收概述

### 什么是垃圾

垃圾是指在**运行程序中没有任何指针指向的对象**。

### 为什么要有GC？

1. 内存迟早会被消 耗完
2. 清除内存里的记录碎片，JVM将整理出内存分配给新的对象
3. 没有GC就不能保证应用程序的正常进行

### JAVA垃圾回收机制

自动内存管理，**降低内存泄漏和内存溢出**的风险

![image-20210827112251076](.\img\image-20210827112251076.png)

## 2. 垃圾回收算法

### 2.1 标记阶段



#### 2.1.1 引用计数算法 

垃圾标记阶段：区分出内存中哪些是存活对象，哪些是死亡对象，只有被标记为死亡的对象，最后才会被释放所占的内存空间。

引用计数算法（Reference Counting）：对每个对象保存一个**整型的引用计数器属性**，用于记录对象被引用的情况。

只要被引用，计数器+1，引用失效，计数器-1，当为0时，即可进行回收。

优点：实现简单，垃圾对象便于标识，判定效率高，回收没有延迟性。

缺点：

	1. 增加了存储空间的开销。
 	2. 加法减法，增加了时间开销。
 	3. 无法处理循环引用的情况。

> Python采用了这种算法，Java没有采用
>
> Python采用了weakref解决循环引用。

#### 2.1.2 可达性分析算法

又称为根搜索算法、追踪性垃圾收集

> “GC Roots”根集合就是一组必须活跃的引用

##### 基本思路

1. 以根对象集合为起始点，按照从上至下的方式 **搜索被根对象集合所连接的目标对象是否可达**。
2. 使用可达性分析算法后，内存中**只有存活的对象**会被根对象集合直接或间接**连接**着，搜索走过的路劲被称为**引用链**
3.  不可达的对象，可以被标记为垃圾对象。

##### GC Roots包含的元素

1. 虚拟机栈中引用的对象

2. 本地方法栈内JNI引用的对象

3. (方法区)类静态属性引用的对象

4. (方法区)常量引用的对象

5. 所有被同步锁synchronized持有的对象

6. Java虚拟机内部的引用（基本数据类型对应的Class对象，类加载器）

7. 反映Java虚拟机内部情况的JMXBean、JVMTi中注册的回调、本地代码缓存

8. 除了固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，**还可以有其他对象“临时性”地加入**，共同构成完整的GC Roots集合，比如：**分代收集和局部回收（Partial GC）**

   > - 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针 对新生代）， 必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的， 这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

由于Root采用栈方式存放变量和指针，如果一个指针，它保存了堆内存里面的对象，但自己又不在堆内存里面，那么它就是一个Root。

##### 注意

- 如果使用可达性分析算法，那么分析工作必须在能保障一致性的快照中进行的。
- 这也是导致GC是必须“Stop The World”的一个重要原因

#### 2.1.3 对象finalization的机制

##### 概述

Java语言提供了对象终止（finalization）机制，来允许开发人员**提供对象被销毁之前的自定义处理逻辑。**

 对象被回收之前，先调用这个对象的finalize()方法

finalize()方法可被重写，**用于在对象被回收时，进行资源释放**。

##### 不要主动调用finalize的理由

> 永远不要主动调用finalize()方法，应该交给垃圾回收机制。

1. finalize()时可能会导致对象复活
2. finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行的机会
3. 一个糟糕的finalize()会严重影响GC性能。

> 从功能上来说，finalize()方法与C++中的析构函数比较相似，但Java采用的是基于垃圾回收器的自动内存管理机制。所以finalize()在本质上不同于C++中的析构函数。

##### 虚拟机中对象可能处于的状态

1. 可触及的：从根节点开始，可以达到这个对象
2. 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
3. 不可触及的：对象的finalize()的调用，并且没有复活，那么就会进入不可触及状态。**不可触及状态不可复活**，**因为finalize只能调用一次**。

##### 具体过程

 	1. 如果对象objA到GC Roots没有引用链，则进行一次标记
 	2. 判断此对象有没有必要执行finalize方法
     1. 如果没有重写finalize或者执行过一次finzlize方法，则被虚拟机视为“没有必要执行”，objA被判断为不可触及的
     2. 如果对象objA重写了finalize方法，但还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发器finalize方法的执行。
     3. **finalize方法是对象逃脱死亡的最后机会**，稍后GC会对F-Queue队列中的对象进行第二次标记。**如果objA在finalize()方法中与引用链上的任何一个对象建立的联系**，那么在第二次标记时，objA会被移除“即将回收”集合。之后，如果对象再次出现没有引用存在的情况下，finalize方法不会被调用，对象会直接变成不可触及的状态（**一个对象的finalize方法只会被调用一次**）

-XX:+HeapDumpOnOutOfMemory //heap OOM时，生成dump文件

### 2.2 清除阶段

#### 2.2.1 标记-清除算法

Mark-sweep

##### 执行过程

当堆中的有效空间被耗尽的时候，就会停止整个程序（Stop The World），然后进行标记和清除

- 标记：Collector从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的Header中记录为可达对象
- 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在期Header中没有标记为可达对象，则进行回收

##### 缺点：

- 效率不算高
- 在进行GC时，需要停止整个应用程序
- 这种方式清理出来的空闲内存是不连续的，会产生内存碎片，需要维护一个空闲列表。

##### 注意：何为清除？

> 这里所谓的清除并不是真的置空，而是把需要清除的对象的地址，保存在空闲列表里，下次有新对象需要加载时，判断垃圾的位置空间是否足够，如果够就直接覆盖（不够，可能会报OOM）

#### 2.2.2 复制算法

##### 执行过程

将活着的内存空间分为两块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

##### 优点：

- 没有标记和清除过程，简单，运行高效
- 复制过去保证空间连续，不会出现碎片

##### 缺点：

- 需要两倍的内存空间
- 对于G1这种拆分为大量region的GC，复制而不是移动，意味着GC需要维护region之间的引用关系，不管是内存占用还是时间开销也不小

##### 特别的：

如果系统中的**非垃圾对象特别多**，复制算法**不会很理想**。因为复制算法需要复制的存活对象数量并不会太大或者说非常低才行。

只有存活对象少的情景下才适合该算法，例如新生代。

#### 2.2.3 标记-压缩算法

标记整理算法、Mark-Compact

> 标记-压缩算法适用于老年代。

##### 执行过程

1. 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用的对象。
2. 将所有的存活对象压缩到内存的一段，按顺序排放。
3. 清理边界外所有的空间。

##### 优点

- 消除了标记-清除算法中，内存区域分散的缺点，给新对象分配内存时，JVM只需要有一个内存的起始地址即可
- 消除了复制算法中，内存减半的代价

##### 缺点

- 效率低于复制算法
- 移动对象时，如果对象被其他对象引用，还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序，即STW



![](D:\01_md\Java\JVM\img\007.png)





![image-20210827102023327](.\img\image-20210827102023327.png)