<?xml version="1.0" encoding="UTF-8" standalone="no"?><opml version="2.0"><head><title>对象的实例化</title><owername>尼古拉皮</owername><producer>XMind</producer><xmind-version>3.7.7</xmind-version></head><body><outline text="对象的实例化"><outline text="创建对象的步骤"><outline text="1. 判断对象对应的类是否加载、链接、初始化"><outline text="虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、链接、初始化（即判断类元信息是否存在）。&#10;如果没有，那么在双亲委派机制下，使用当前来加载器以ClassLoader+包名+类名为Key进行查找对应的Class文件。&#10;如果没有找到文件，则抛ClassNotFoundException异常，&#10;如果找到，则进行类加载，并生成对应的Class类对象。" type="note"/></outline><outline text="2. 为对象分配内存"><outline text="如果内存规整"><outline text="如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。&#10;意思是所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。&#10;如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法，虚拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。" type="note"/></outline><outline text="如果内存不规整"><outline text="如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。&#10;意思是虚拟机维护了一个列表，记录上哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为空闲列表（Free List）" type="note"/><outline text="虚拟机维护空闲列表"/></outline><outline text="说明"><outline text="选择哪种分配方式由Java堆是否规整决定，&#10;而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定" type="note"/></outline></outline><outline text="3. 处理并发全问题"><outline text="采用CAS失败重试、区域加锁保证更新的原子性"/><outline text="每个线程预先分配一块TLAB"><outline text="通过-XX:+UseTLAB参数设定"/></outline></outline><outline text="4. 初始化分配到的空间"><outline text="所有属性设置默认值，保证对象实例字段在不赋值的时候可以直接使用"/></outline><outline text="5. 设置对象头"><outline text="将对象所属的类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM的实现。" type="note"/></outline><outline text="6. 执行init方法进行初始化"><outline text="初始化成员变量、执行实例化代码块、调用类的构造方法，并把堆内对象的首地址赋值给引用变量" type="note"/></outline></outline><outline text="创建对象的方式"><outline text="new"><outline text="最常见的方式"/><outline text="变形1:Xxx的静态方法"/><outline text="变形2:Xxxbuilder/XxxFactory的静态方法"/></outline><outline text="Class的newInstance():反射的方式，只能调用空参的构造器，权限必须是public"/><outline text="Constructor的newInstance(Xxx):反射的方式，可以调用空参、带参的构造器，权限没有要求"/><outline text="使用clone():不调用任何构造器，当前类需要实现Cloneable结构，实现clone()"/><outline text="使用反序列化:从文件中、网络中获取一个对象的二进制流"/><outline text="第三方库Objenesis"/></outline></outline></body></opml>