

## **执行引擎（Execution Engine）**

### 1. **概述**

执行引擎是Java虚拟机核心的组成部分之一

**虚拟机的执行引擎则是由软件自行实现，不受物理条件的制约，能够执行不被硬件支持的指令集**

**JVM的主要任务负责：装载字节码到其内部**

**执行引擎的任务：将字节码指令解释/编译为对应平台上的本地机器指令才可以。**

### 2. **过程**

1. 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。

2. 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。

3. 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。

### 3. **Java代码编译和执行的过程**

Java代码编译是由Java源码编译器来完成的

<img src=".\img\001.jpeg" alt="img" style="zoom:150%;" />

Java字节码的执行是由JVM执行引擎来完成的

<img src=".\img\002.png" alt="002"  />

**什么是解释器（Interperter）？什么是JIT编译器？**

解释器：当Java虚拟机启动时，会根据预定义的规范**对字节码采用逐行解释的方式执行**

JIT（Just In Time Compiler）编译器：将源代码编译成和本地机器平台相关的机器语言

**为什么说Java是半编译半解释型语言？**

JDK1.0，将Java语言定位为解释执行，

现在执行Java代码时，通常都会绛解释执行和编译执行结合起来进行。

![003](.\img\003.png)

- 解释型语言走中间一行
- 编译型语言走下边一行

### 4. **机器码、指令、汇编语言**

1. 机器码

采用二进制编码的方式表示的指令，叫做**机器指令码/机器语言**

与其他语言比，执行最快

2. 指令

简化机器码，成为可读性好的指令

指令集，不同的硬件所支持的指令是不同的，每个平台所支持的指令，称之为对应平台的指令集。

3. 汇编语言

用助记符（Mnemonics）代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。

4. 高级语言

更接近人的语言，分为：解释型和编译型

5. 字节码

字节码是一种**中间状态（中间码）的二进制代码（文件）**，它比机器码更抽象，需要直译器转译后才能成为机器码

字节码主要为了实现特定软件运行和软件环境，与硬件环境无关

![004](.\img\004.png)

### 5. **解释器**

可分为：

字节码解释器：纯软件代码模拟字节码的执行，效率低下

模板解释器（现在普遍使用）：将每一条字节码和一个模板函数相关联，模板函数可直接产生这条字节码执行时的机器码。

在HotSpot中，解释器分为Interpreter模块和Code模块

- - - Interpreter模块：实现解释器的核心功能
    - Code模块：用于管理HostSpotVM在运行时生产的本地机器指令

JVM支持即时编译技术，将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码。

### 6. **JIT编译器（Just In Time）**

执行效率高，对比解释器。

编译器分类：

前端编译器：把.java文件转换成.class文件，Sun的Javac、Eclipse JDT中的增量式编译器。

后端运行期编译器（JIT 编译器）：把字节码转换成机器码，HotSpot VM的 C1、C2编译器。

静态提前编译器（AOT编译器，Ahead Of TIme）：直接把.java文件编译成本地机器代码，GCJ、Excelsior JET。

#### 6.1 **热点代码及探测方式**

##### 概述

是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，需要根据代码被调用执行的频率决定。需要被编译的代码称之为“热点代码”，JIT 编译器对“热点代码”作出深度优化，将其编译为本地机器指令。

由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为**OSR** （On StackReplacement）编译。

##### **探测方式**

HotSpot VM 采用的热点探测方式是基于计数器的热点探测。

为每一个方法建立两个不同类型的计数器：

#### 6.2 **方法调用计数器（Invocation Counter）：**

用于统计方法的调用次数，阈值默认在Client模式下是1500次；在Server模式下是10000次。

超过这个次数就会触发JIT编译。

阈值设定：-XX:CompileThreshold

方法被调用时，会检查是否存在被JIT编译过的版本，

- - 如果存在，则优先使用编译后的本地代码来执行。

  - 如果不存在，此方法的调用计时器+1，

  - - 再继续判断，方法调用计数器与回边计数器**之和**是否超过方法调用计数器的阈值，

- - - - 如果超过阈值，则提交该方法的代码编译请求。

        如果没有超过，解释执行。

##### **热度衰减**

方法调用计数器统计的并不是方法被调用的绝对次数，而是**一段时间之内方法被调用的次数**。

当超过一定的时间限度，调用次数仍不够阈值，那么该方法的方法调用计数器会**减少一半**，这个过程称为方法调用计数器热度的**衰减**（Counter Decay），这段时间被称为此方法统计的**半衰周期**（Counter Half Life Time）。

热度衰减的动作，是在虚拟机进行垃圾收集时顺便进行的。

使用-XX:-UseCounterDecay来关闭热度衰减。

使用-XX:CounterHalfLifeTime设置半衰周期的时间（秒）。

#### 6.3 **回边数器（Back Edge Counter）：**

统计一个方法中循环体代码执行的次数。在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。

过程与方法调用计数器一样。

#### 6.4 **JIT分类**

1. Client Compiler：

-client：指定Java虚拟机运行在Client模式下，并使用C1编译器

C1编译器会对字节码进行**简单和可靠的优化**，耗时短

2. Server Compiler

-server：指定Java虚拟机运行在Server模式下，使用C2编译器

C2进行耗时**较长的优化，以及激进优化**，执行效率更高

#### 6.5 **C1和C2编译器不同的优化策略**

1. C1编译器的优化
   - 方法内联：将引用的函数代码编译到引用处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
   - 去虚拟化：对唯一的实现类进行内联
   - 冗余消除：在运行期间吧一些不会执行的代码折叠掉
2. C2编译器的优化：主要在**全局层面**进行优化，基于**逃逸分析**
   - 标量替换：用标量值代替聚合对象的属性值
   - 栈上分配：对为逃逸的对象分配在栈而不是堆
   - 同步消除：清楚同步操作，通常指synchronized

### 7. **HsotSpot JVM的执行方式**

#### 7.1 **概述**

HostSpot VM，采用**解释器与即时编译器并存的架构**。

**即时编译比解释执行快很多，但为什么还需要解释执行呢？**

**比如JRockit VM内部不包含解释器。**

因为解释器响应速度快，编译器想要发挥作用还需要把代码编译成本地代码，需要一定的执行时间，但编译为本地代码后，执行效率高。

当虚拟机启动的时候，解释器首先发挥作用，不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，换取更高的执行效率。

![005](.\img\005.png)

#### 7.2 **分层(Tiered Compilation)编译策略**

程序解释执行（不开启性能监控）可以出发C1编译，将字节码编译成机器码，可以进行简单优化。

也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。

在JDK7之后，显示指定命令“-server”，就会开启分层编译策略，由C1 和 C2相互协作共同来执行编译任务。

#### 7.3 **设置程序执行方式**

-Xint：完全采用解释器模式执行

-Xcomp：完全采用即时编译器模式执行，如果编译出现问题，解释器会介入执行

-Xmixed：采用解释器+即时编译器的混合模式共同执行

### 8. 补充

#### Graal编译器

- 自JDK10起，HotSpot又加入一个全新的即时编译器： Graal编译器
- 编译效果短短几年时间就追评了C2编译器。未来可期。
- 目前，带着“实验状态"标签，需要使用开关参数 -XX： +UnlockExperimentalVMOptions 一XX： +UseJVMCICompiler去激活，才可以使用。

#### AOT编译器

- 静态提前编译器，Ahead Of Time Compiler
- JAVA 9 引入AOT编译工具jaotc（.class-->.so），将所输入的Java类文件转换为机器码，并存放至生产的动态链接库中
- 不同与即时编译器，即时编译器是在**程序运行过程中**进行的，
- AOT编译器指的是在**程序运行之前**进行编译的。
- 优点：
  1. 不必等待即时编译器的预热
- 缺点：
  1. 破坏了java“一次编译，到处运行”
  2. 降低了Java链接过程的动态性

![](.\img\JVM底层体系.jpg)

